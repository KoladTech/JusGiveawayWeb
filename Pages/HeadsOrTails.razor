@page "/heads-or-tails/{PlayerUID?}"
@inject NavigationManager NavigationManager
@inject JusGiveawayWebApp.Helpers.CommonFunctions CommonFunctions
@inject JusGiveawayWebApp.Services.FirebaseService FirebaseService
@inject JusGiveawayWebApp.Services.UserInfoService UserInfoService
@inject IndexedDB.Blazor.IIndexedDbFactory DbFactory
@inject IJSRuntime JSRuntime
@using JusGiveawayWebApp.Models
@using JusGiveawayWebApp.Services
@using JusGiveawayWebApp.Helpers

<div class="phone-container">
    <div class="phone-screen">
        <div class="game-info">
            <!-- First Row -->
            <div class="player-info">
                <img src="images/avatar_green.png" alt="Player Avatar" />
                <div>
                    <p>@PlayerName</p>
                    <p>@PlayerChoice</p>
                </div>
            </div>
            <div class="giveaway-info">
                <p>Giveaway Balance</p>
                <p class="funds">N@(animateVarForLeftoverGiveawayFunds.ToString("N0"))</p>
                <p @onclick="OnSponsoredByTapped" class="sponsored-link">Sponsored by...</p>
            </div>

            <!-- Second Row -->
            <div class="winning-info">
                <p>Maximum Win</p>
                <p class="funds">N@(animateVarForMaximumWin.ToString("N0"))</p>
            </div>
            <div class="giveaway-info">
                <p>Your Winnings</p>
                <p class="funds">N@(animateVarForWinnings.ToString("N0"))</p>
            </div>

            <!-- Third Row -->
            <div class="resets-left" style="grid-column: 1 / -1;">
                @foreach (var heart in HeartImages)
                {
                    <img src="@heart.Source"
                         @onclick="ToggleResetCountVisibility"
                         id="@heart.Id"
                         class="hearts @heartClass[@heart.Id-1]"
                         alt="Heart"
                         style="cursor: pointer;" />
                }
                @if (isResetCountVisible)
                {
                    <p class="@resetCounterParagraphClass">@ResetsLeft resets left</p>
                }
            </div>
        </div>


        <!-- Side choice section -->
        <div class="side-choice-section transition-fade @(SideSelected ? "hidden" : "show")">
            <p>@PlayerChoice</p>
            <div class="coin-images">
                <img src="images/kobo_front.png" alt="Coin Front"
                        class="@((PlayerChoice == "Heads") ? "coin selected" : "coin")"
                        style="width: 100px; height: 100px;" @onclick="OnChooseHeadsTapped" />
                <img src="images/kobo_back.png" alt="Coin Back"
                        class="@((PlayerChoice == "Tails") ? "coin selected" : "coin")"
                        style="width: 100px; height: 100px;" @onclick="OnChooseTailsTapped" />
            </div>
            <button class="centered-button" @onclick="OnLockInSelectionClicked" disabled="@(!IsUserMakingChoice)">Start Game</button>
        </div>
        
        <!--Game play section -->
        <div class="transition-fade @(SideSelected ? "show" : "hidden")">
            @if (isGameOver)
            {
                <div class="game-over-message">
                    Game Over
                </div>
            }

             @if (!isGameOver)
            {
                <div id="tap-prompt" class="prompt-message show">Tap the coin to flip!</div>
            }

            <!-- Rounds Complete -->
           
            <p class="round-label gameplay-content-centered" title="Total rounds completed: @(TotalFlips / 100)">
				Round: @(TotalFlips / 100 + 1)
				<i class="fas fa-flag-checkered"></i>
            </p>

            <!-- Coin Image -->
			<div class="gameplay-content-centered">
                <img class="coin-image  @(isFlipping ? "flipping" : "") @(isShaking ? "shake-effect" : "")" src="@CoinImage" alt="Coin" @onclick="OnCoinTapped" />
            </div>

            <!-- Total Label -->
            <div class="gameplay-content-centered">
                <p>Total Flips: @TotalFlips</p>
            </div>

            <div class="grid-layout">
                <!-- Heads Column -->
                <div class="bar-column">
                    <div class="bar-frame">
                        <div class="bar" style="height: @HeadsBarHeight%;"> </div>
                    </div>
                    <label class="label">Heads</label>
                    <label class="count-label">@HeadsCount</label>
                </div>

                <!-- Tails Column -->
                <div class="bar-column">
                    <div class="bar-frame">
                        <div class="bar tails-bar" style="height: @TailsBarHeight%;"> </div>
                    </div>
                    <label class="label">Tails</label>
                    <label class="count-label">@TailsCount</label>
                </div>
            </div>

            <!-- Score -->
            <div class="gameplay-content-centered">
                <div class="score-display">
                    <p class="score-text">
                        Score:
                        <span class="score-value @(Score >= 0 ? "positive" : "negative")">@Score</span>
                    </p>
                </div>
            </div>

            <!-- Button container with Flexbox layout -->
            <div style="display: flex; justify-content: space-between; align-items: center;">

                <!-- Back button (left-aligned) -->
                <button @onclick="OnBackBtnClicked" class="back-button">
                    <img src="images/back_icon.png" class="back-icon" />
                </button>

                <!-- Spacer to ensure the right button stays aligned on the right -->
                <div style="flex-grow: 1;"></div>

                <!-- Reset button (right-aligned) -->
                <button @onclick="OnResetClicked" class="centered-button transition-fade @(ShowResetBtn ? "show" : "hidden")">
                    Switch to @ResetBtnText
                </button>

                <!-- Cash Out button (right-aligned) -->
                <button @onclick="OnCashOutClicked" class="transition-fade @(ShowCashOutBtn ? "show" : "hidden") centered-button">
                    Cash Out
                </button>
            </div>

            <div class="end-round-message @(wonRound ? "win animate" : "") @(lostRound ? "loss animate" : "") @(bingoRound ? "bingo animate" : "")">
                @(EndOfRoundMessage)
            </div>
        </div>
    </div>
</div>

<!-- Sponsors Modal -->
<SponsorsModal ShowModal="ShowModal" ShowModalChanged="OnModalStateChanged" SponsorName=@SponsorName SponsorInstagramAcct=@SponsorInstagramAcct />

<Toast Message="@toastMessage" IsVisible="@isToastVisible" IsVisibleChanged="@(val => isToastVisible = val)" />

<CustomAlertDialog ShowDialog="@ShowDialog" DialogParams="@alertDialogParams" />

@code {
    private string PlayerName { get; set; } = "whoRu?";
    private string PlayerChoice { get; set; } = "Heads or Tails";
    [Parameter]
    public string PlayerUID { get; set; } = ""; 
    private double LeftoverGiveawayFunds { get; set; } = 0;
    private double MaxPossibleWinnings { get; set; } = 0;
    private double CurrentWinnings { get; set; } = 0;
    private double animateVarForLeftoverGiveawayFunds { get; set; } = 0;
    private double animateVarForMaximumWin { get; set; } = 0;
    private double animateVarForWinnings { get; set; } = 0;
    private int TotalFlips => HeadsCount + TailsCount;
    private int HeadsCount { get; set; } = 0;
    private int TailsCount { get; set; } = 0;
    private int Score => (HeadsCount - TailsCount) * scoreAdjuster;
    private int scoreAdjuster { get; set; } = 1;
    private bool IsUserMakingChoice { get; set; } = false;
    private bool ShowCashOutBtn { get; set; } = false;
    private bool ShowResetBtn { get; set; } = true;
    private string ResetBtnText { get; set; } = "Heads/Tails";
    private bool SideSelected = false;
    private string EndOfRoundMessage { get; set; } = "";
    // Calculate height for the bars based on counts
    private double HeadsBarHeight => TotalFlips > 0 ? (double)HeadsCount / TotalFlips * 100 : 0;
    private double TailsBarHeight => TotalFlips > 0 ? (double)TailsCount / TotalFlips * 100 : 0;
    private bool isFlipping = false;
    private string CoinImage = "images/kobo_front.png";
    private GiveawayData? _giveawayData;
    private UserGamePlayData? userGamePlayData;
    private List<UserGamePlayData> gameDataList = new List<UserGamePlayData>();
    private int ResetsLeft { get; set; } = 0;
    private bool isResetCountVisible = false;
    private string resetCounterParagraphClass = ""; // Class for the paragraph
    private List<HeartImage> HeartImages { get; set; } = new List<HeartImage>();
    private string[] heartClass;  // Store classes for each heart for animation
    private Timer _timer;
    private string _lastETag = null;
    private FirebaseAuthResponse _firebaseResponse;
    private HttpResponseMessage httpResponseMessage;
    private bool isToastVisible;
    private string toastMessage;
    private bool ShowDialog = false;
    private AlertDialogParams alertDialogParams = new AlertDialogParams(); 
    private bool isShaking = false;
    private DotNetObjectReference<HeadsOrTails>? objRef; 
    private bool isUserLoggedIn = true; // Assume user is logged in initially
    private bool isGameOver = false; 
    private bool isSaving = false;
    private bool ShowModal { get; set; } = false;
    private string SponsorName { get; set; } = "Sponsor_placeholder";
    private string SponsorInstagramAcct { get; set; } = "Sponsor_instagram_acct";
    //private bool navigationManagerForceReload { get; set; } = true;


    protected override void OnInitialized()
    {
        if (string.IsNullOrEmpty(PlayerUID))
        {
            // Redirect to the sign-in page
            NavigationManager.NavigateTo("/");
            return;
        }

        //store uid in UserInfoService singleton to use in NavMenu
        UserInfoService.PlayerUID = PlayerUID;

        // NavigationManager.LocationChanged -= OnLocationChanged;        
        // NavigationManager.LocationChanged += OnLocationChanged;
    }

    protected override async Task OnInitializedAsync()
    {
        try
        {
            using (var db = await this.DbFactory.Create<JusGiveawayDB>())
            {
                var user = CommonFunctions.GetUserInfoFromIndexedDb(db, PlayerUID);

                //check if user is logged in, if not, return to login screen
                if (user == null || CommonFunctions.SendUserBackToLogInPageIfNotLoggedIn(user))
                {
                    NavigationManager.NavigateTo("/");
                    return;
                }
                else
                {
                    //set auth token in case of a refresh of page
                    bool authTokenExpired = await FirebaseService.SetAuthTokenIfNotExpired(user.IdToken);
                    if (authTokenExpired)
                    {
                        await CommonFunctions.SignOutUser(this.DbFactory, PlayerUID);
                        NavigationManager.NavigateTo("/");
                        return;
                    }


                    //rethink. this is absolutely necessary. If null, its a problem innit?
                    _giveawayData = await CommonFunctions.GetGiveawayDataFromFirebase();
                    //get latest data from firebase
                    userGamePlayData = await CommonFunctions.GetUserGamePlayDataFromFirebase(PlayerUID);
                    //check the size of the reads

                    PlayerName = user.Name ?? "GameError";
                    SponsorName = _giveawayData.Sponsor;
                    SponsorInstagramAcct = _giveawayData.SponsorInstagramAccount;
                }

                if (userGamePlayData == null)
                {
                    //no data in firebase, so lets check local as well. they might have a game going which hasn't been pushed to firebase
                    Console.WriteLine("no game play data in firebase");
                    userGamePlayData = CommonFunctions.GetUserGamePlayDataFromIndexedDb(db, PlayerUID);

                    if (userGamePlayData == null)
                    {
                        //if still null, then its first time playing
                        Console.WriteLine("no game play data - first time playing");
                        userGamePlayData = new UserGamePlayData()
                            {
                                UID = PlayerUID,
                                SelectedSides = false,
                                PlayingHeads = false,
                                HeadsCount = 0,
                                TailsCount = 0,
                                MaxPossibleWinnings = _giveawayData.MaxPossibleWinningsPerPerson,
                                CurrentWinnings = 0,
                                MinCashOut = _giveawayData.MinCashoutPerPerson,
                                TotalResetsLeft = _giveawayData.TotalResetsAllowed,
                                LifetimeHeadsCount = 0,
                                LifetimeTailsCount = 0,
                                GameOver = false,
                                CashedOut = false
                            };
                    }
                    db.UserGameDatas.Add(userGamePlayData);
                    await db.SaveChanges();
                }
                else
                {
                    Console.WriteLine("game play data EXISTS");
                    //store gameplaydata in indexeddb
                    var userGamePlayDataFromIndexedDB = CommonFunctions.GetUserGamePlayDataFromIndexedDb(db, PlayerUID);
                    if (userGamePlayDataFromIndexedDB == null)
                    {
                        db.UserGameDatas.Add(userGamePlayData);
                        await db.SaveChanges();
                    }
                    else
                    {
                        db.UserGameDatas.Remove(userGamePlayDataFromIndexedDB);
                        db.UserGameDatas.Add(userGamePlayData);
                        await db.SaveChanges();
                    }
                }
                //populate all thats needed
                startGameUISetup(userGamePlayData, _giveawayData);

                //function which helps with sign out on inactivity
                await OnLoginSuccess();
            }
        }
        catch(Exception ex)
        {
            Console.WriteLine(ex.Message);
        }

        AddHeartImages();
        await GetLeftoverGiveawayFundsFromFirebase();
    }

    private async Task LoadGameDataFromDb()
    {
        using (var db = await DbFactory.Create<JusGiveawayDB>())
        {
            // Fetch all records from the GameDataSet
            gameDataList = db.UserGameDatas.ToList<UserGamePlayData>();
        }
    }

    private async Task AnimateNumberChange(Action<double> updateValue, double startValue, double endValue, int duration = 2000)
    {
        int stepDuration = 20; // Duration between each step (in milliseconds)
        int steps = duration / stepDuration; // Total number of steps for the animation

        // Calculate increment value per step
        double incrementValue = (endValue - startValue) / steps;
        double currentValue = startValue;

        // Perform the animation in a loop
        for (int i = 0; i < steps; i++)
        {
            currentValue += incrementValue; // Increment the value
            updateValue(currentValue); // Update the value using the provided delegate
            StateHasChanged(); // Notify Blazor to re-render the UI
            await Task.Delay(stepDuration); // Wait for the next step
        }

        // Set the final value to ensure precision
        updateValue(endValue);
        StateHasChanged(); // Final update
    }

    //just quickly created an overloaded function. Look into this later
    private async Task AnimateNumberChange(Action<int> updateValue, int startValue, int endValue, int duration = 2000)
    {
        int stepDuration = 20; // Duration between each step (in milliseconds)
        int steps = duration / stepDuration; // Total number of steps for the animation

        // Calculate increment value per step
        int incrementValue = (endValue - startValue) / steps;
        int currentValue = startValue;

        // Perform the animation in a loop
        for (int i = 0; i < steps; i++)
        {
            currentValue += incrementValue; // Increment the value
            updateValue(currentValue); // Update the value using the provided delegate
            StateHasChanged(); // Notify Blazor to re-render the UI
            await Task.Delay(stepDuration); // Wait for the next step
        }

        // Set the final value to ensure precision
        updateValue(endValue);
        StateHasChanged(); // Final update
    }

    private async void ToggleResetCountVisibility()
    {
        isResetCountVisible = !isResetCountVisible; // Toggle the visibility

        if (isResetCountVisible)
        {
            resetCounterParagraphClass = "fade-in"; // Apply fade-in class
            StateHasChanged(); // Trigger re-render

            await Task.Delay(2000); // Wait for 2 seconds (fade-in duration)

            resetCounterParagraphClass = "fade-out"; // Apply fade-out class
            await Task.Delay(2000); // Wait for 2 seconds (fade-out duration)

            isResetCountVisible = false; // Set visibility to false after fade-out
            resetCounterParagraphClass = ""; // Reset class
            StateHasChanged(); // Trigger re-render
        }
        else
        {
            // If clicked again, immediately hide it (optional)
            isResetCountVisible = false;
            resetCounterParagraphClass = ""; // Reset class
            StateHasChanged(); // Trigger re-render
        }
    }

    private void OnChooseHeadsTapped()
    {
        PlayerChoice = "Heads";
        scoreAdjuster = 1;
        IsUserMakingChoice = true;
    }

    private void OnChooseTailsTapped()
    {
        PlayerChoice = "Tails";
        scoreAdjuster = -1;
        IsUserMakingChoice = true;
    }

    private async void OnLockInSelectionClicked()
    {
        Console.WriteLine(SideSelected);
        // Logic for starting the game
        SideSelected = true;
        Console.WriteLine(SideSelected);

        ResetBtnText = PlayerChoice == "Heads" ? "Tails" : "Heads";

        //store side selection in indexeddb
        try
        {
            using (var db = await this.DbFactory.Create<JusGiveawayDB>())
            {
                var userGamePlayData = CommonFunctions.GetUserGamePlayDataFromIndexedDb(db, PlayerUID);
                if (userGamePlayData != null)
                {
                    userGamePlayData.SelectedSides = true;
                    userGamePlayData.PlayingHeads = PlayerChoice == "Heads" ? true : false;
                    await db.SaveChanges();
                }
            }
        }
        catch (Exception ex)
        {
            await CommonFunctions.WriteErrorMessageToFirebase(ex.Message, "OnLockInSelectionClicked", DateTime.Now.ToString());
            Console.WriteLine(ex.Message);
        }
    }

    private async void OnCoinTapped()
    {
        //just an animation for fun
        if (userGamePlayData.GameOver)
        {
            await ShakeImage();
        }
        // Logic for flipping the coin
        if (isFlipping || isMaxWinAchieved() || userGamePlayData.GameOver)
            return; // Prevent multiple clicks while flipping

        isFlipping = true;
        ShowCashOutBtn = isMaxWinAchieved();
        ShowResetBtn = !ShowCashOutBtn;
        StateHasChanged();

        Random random = new Random();
        int totalSpins = 15;  // Total number of flips (adjust as needed)

        // Rotate the coin and switch images for a spinning effect
        for (int i = 0; i < totalSpins; i++)
        {
            CoinImage = i % 2 == 0 ? "images/kobo_front.png" : "images/kobo_back.png"; // Alternate front/back
            StateHasChanged();

            await Task.Delay(50); // Adjust this value to control the speed of spinning
        }

        // Final outcome based on random result (0 = heads, 1 = tails)
        if (random.Next(2) == 0)
        {
            CoinImage = "images/kobo_front.png"; // Set to heads
            HeadsCount += 10;
        }
        else
        {
            CoinImage = "images/kobo_back.png"; // Set to tails
            TailsCount += 10;
        }

        CheckForWin();

        //save coin flips to indexeddb after every 10 flips
        if (TotalFlips % 10 == 0)
        {
            SaveGamePlayProgressToIndexedDB();
        }

        isFlipping = isMaxWinAchieved();

        StateHasChanged(); // Update UI after flipping is complete
    }

    //in the future, use this everywhere you do saves to IndexedDB to make the code cleaner
    private async void SaveGamePlayProgressToIndexedDB()
    {
        try
        {
            using (var db = await this.DbFactory.Create<JusGiveawayDB>())
            {
                userGamePlayData = CommonFunctions.GetUserGamePlayDataFromIndexedDb(db, PlayerUID);
                if (userGamePlayData != null)
                {
                    userGamePlayData.HeadsCount = HeadsCount;
                    userGamePlayData.TailsCount = TailsCount;
                    userGamePlayData.MaxPossibleWinnings = (int)MaxPossibleWinnings;
                    userGamePlayData.CurrentWinnings = (int)CurrentWinnings; // casting to int, but I should probably change CurrentWinnings to a double in the first place
                    userGamePlayData.GameOver = isGameOver;

                    await db.SaveChanges();
                }
            }
        }
        catch (Exception ex)
        {
            await CommonFunctions.WriteErrorMessageToFirebase(ex.Message, "SaveGamePlayProgressToIndexedDB", DateTime.Now.ToString());
            Console.WriteLine(ex.Message);
            //await CommonFunctions.DisplayCustomAlertPage("Error", "Error saving game state to DB, please contact app devs", "Close", "", true, false, AlertType.Error, Navigation);
        }
    }

    private async void startGameUISetup(UserGamePlayData userGamePlayData, GiveawayData giveawayData)
    {
        SideSelected = userGamePlayData.SelectedSides;
        if (SideSelected)
        {
            PlayerChoice = userGamePlayData.PlayingHeads ? "Heads" : "Tails";
        }
        else
        {
            PlayerChoice = "Choose Heads/Tails";
        }

        ResetBtnText = PlayerChoice == "Heads" ? "Tails" : "Heads";
        HeadsCount = userGamePlayData.HeadsCount;
        TailsCount = userGamePlayData.TailsCount;
        ResetsLeft = userGamePlayData.TotalResetsLeft;
        scoreAdjuster = userGamePlayData.PlayingHeads ? 1 : -1;
        ShowCashOutBtn = ((userGamePlayData.HeadsCount + userGamePlayData.TailsCount) % 100 == 0) && (userGamePlayData.CurrentWinnings >= userGamePlayData.MinCashOut) && !userGamePlayData.CashedOut;
        ShowResetBtn = !ShowCashOutBtn && !userGamePlayData.GameOver;
        isGameOver = userGamePlayData.GameOver;

        animateVarForLeftoverGiveawayFunds = LeftoverGiveawayFunds;
        animateVarForMaximumWin = MaxPossibleWinnings;
        animateVarForWinnings = CurrentWinnings;
        LeftoverGiveawayFunds = giveawayData.LeftoverGiveawayFunds;
        MaxPossibleWinnings = userGamePlayData.MaxPossibleWinnings;
        CurrentWinnings = userGamePlayData.CurrentWinnings;

        await Task.WhenAll(
            AnimateNumberChange(value => animateVarForLeftoverGiveawayFunds = value, animateVarForLeftoverGiveawayFunds, LeftoverGiveawayFunds),
        AnimateNumberChange(value => animateVarForMaximumWin = value, animateVarForMaximumWin, MaxPossibleWinnings),
        AnimateNumberChange(value => animateVarForWinnings = value, animateVarForWinnings, CurrentWinnings)
        );

        //if gameover, we lock the game
        if (userGamePlayData.GameOver)
        {
            LockGame();
        }
    }

    private void OnCashOutClicked()
    {
        ShowDialog = true;

        if (!isGameOver)
        {
            alertDialogParams.AlertTitle = "Cash Out?";
            alertDialogParams.AlertMessage = new MarkupString($"Are you sure you are ready to cash out N{CurrentWinnings.ToString("N0")}?<br/><br/> If you proceed with cashing out, it will be game over!");
            alertDialogParams.OnPrimaryButtonClick = EventCallback.Factory.Create(this, AlertDialogPrimaryClicked);
            alertDialogParams.OnSecondaryButtonClick = EventCallback.Factory.Create(this, AlertDialogSecondaryClicked);
        }
        else
        {
            alertDialogParams.AlertTitle = "Cash Out!";
            alertDialogParams.AlertMessage = new MarkupString($"Please cash out your winnings of N{CurrentWinnings.ToString("N0")}?<br/><br/> Thanks for playing!");
            alertDialogParams.PrimaryBtnText = "Cash out";
            alertDialogParams.SecondaryBtnText = "Exit";
            alertDialogParams.OnPrimaryButtonClick = EventCallback.Factory.Create(this, AlertDialogPrimaryClicked);
            alertDialogParams.OnSecondaryButtonClick = EventCallback.Factory.Create(this, AlertDialogSecondaryClicked);
        }
    }

    private async void OnResetClicked()
    {
        ShowDialog = true;

        int resetPenalty = _giveawayData.MonetaryResetPenalty;
        double resetMaxPossibleWinnings = MaxPossibleWinnings - resetPenalty;
        resetMaxPossibleWinnings = Math.Max(resetMaxPossibleWinnings, _giveawayData.MinCashoutPerPerson);

        alertDialogParams.AlertTitle = $"Switch to {ResetBtnText}?";
        alertDialogParams.AlertMessage = new MarkupString($"There will be a penalty of <strong>N{resetPenalty.ToString("N0")}</strong>!<br/><br/>" +
                $"Maximum possible winnings will be reduced to <strong>N{resetMaxPossibleWinnings.ToString("N0")}</strong>! ");
        alertDialogParams.OnPrimaryButtonClick = EventCallback.Factory.Create(this, AlertDialogPrimaryClicked);
        alertDialogParams.OnSecondaryButtonClick = EventCallback.Factory.Create(this, AlertDialogSecondaryClicked);
        //await LoadGameDataFromDb();
    }

    private async Task ResetDataInDBs()
    {
        try
        {
            using (var db = await this.DbFactory.Create<JusGiveawayDB>())
            {
                userGamePlayData = CommonFunctions.GetUserGamePlayDataFromIndexedDb(db, PlayerUID);

                if (userGamePlayData != null)
                {
                    userGamePlayData.SelectedSides = false;
                    userGamePlayData.PlayingHeads = false;
                    userGamePlayData.HeadsCount = 0;
                    userGamePlayData.TailsCount = 0;
                    userGamePlayData.MaxPossibleWinnings -= _giveawayData.MonetaryResetPenalty;
                    userGamePlayData.CurrentWinnings = (int)CurrentWinnings;
                    userGamePlayData.TotalResetsLeft -= 1;
                    userGamePlayData.LifetimeHeadsCount += HeadsCount;
                    userGamePlayData.LifetimeTailsCount += TailsCount;

                    await db.SaveChanges();
                }
            }
        }
        catch (Exception ex)
        {
            await CommonFunctions.WriteErrorMessageToFirebase(ex.Message, "HeadsOrTails - ResetDataInDBs()", DateTime.Now.ToString());
            Console.WriteLine(ex.Message);
        }

        //save reset to firebase
        try
        {
            bool userSaved = await CommonFunctions.SaveUserGamePlayDataToFirebase(userGamePlayData);
        }
        catch (Exception x)
        {
            Console.WriteLine($"Error saving gameplay data to firebase - {x.Message}");
        }
    }

    private async Task ResetUI()
    {
        animateVarForMaximumWin = MaxPossibleWinnings;
        MaxPossibleWinnings -= _giveawayData.MonetaryResetPenalty;

        await Task.WhenAll(
        AnimateNumberChange(value => animateVarForMaximumWin = value, animateVarForMaximumWin, MaxPossibleWinnings),
        AnimateNumberChange(value => HeadsCount = value, HeadsCount, 0),
        AnimateNumberChange(value => TailsCount = value, TailsCount, 0),
        TriggerHeartAnimation(ResetsLeft)
        );
        SideSelected = false;
        PlayerChoice = "Choose Heads/Tails";
        IsUserMakingChoice = false;
        ResetsLeft -= 1;
        AddHeartImages();
        ShowResetBtn = true;
        StateHasChanged();
    }

    private void AddHeartImages()
    {
        HeartImages = new List<HeartImage>();
        int i = 0;

        // Green hearts for resets remaining
        for (i = 1; i <= ResetsLeft; i++)
        {
            if (i % 2 == 1){
                HeartImages.Add(new HeartImage
                    {
                        Source = "images/green_heart_left.png",
                        Id = i
                    });
            }
            else{
                HeartImages.Add(new HeartImage
                    {
                        Source = "images/green_heart_right.png",
                        Id = i
                    });
            }
        }

        // Grey hearts for the number of used resets
        for (int j = i; j < i + _giveawayData.TotalResetsAllowed - ResetsLeft; j++)
        {
            if (j % 2 == 1)
            {
                HeartImages.Add(new HeartImage
                    {
                        Source = "images/grey_heart_left.png",
                        Id = j
                    });
            }
            else{
                HeartImages.Add(new HeartImage
                    {
                        Source = "images/grey_heart_right.png",
                        Id = j
                    });
            }
        }

        heartClass = new string[HeartImages.Count];
    }

    private class HeartImage
    {
        public string Source { get; set; }
        public int Id { get; set; }
    }

    //TODO: Currently animation is not working. look into how to trigger it
    private async Task TriggerHeartAnimation(int heartId)
    {
        // Remove the class briefly to reset the animation
        heartClass[heartId - 1] = "";
        StateHasChanged();

        // Wait a brief moment to allow reflow, then re-apply the animation class
        await Task.Delay(50);
        heartClass[heartId - 1] = "heart-drop";
        StateHasChanged();  // Re-render the UI
    }

    private async void CheckForWin()
    {
        bool playerWon = false;
        //ShowCashOutBtn = false;
        //ShowResetBtn = !ShowCashOutBtn;
        string roundCompleteMsg = $"Round {(TotalFlips / 100)} complete!";
        string winMsg = string.Empty;
        string lossMsg = "You did not win this time.";
        string additionalMsg = string.Empty;
        double winning = 0;
        int loss = 0;
        bool wonRound = false;
        bool lostRound = false;
        bool bingoRound = false;

        // Check for win only when total flips reach a multiple of 100
        if (TotalFlips >= 100 && TotalFlips % 100 == 0)
        {
            if (Score >= 0)
            {
                playerWon = true;

                if (Score == 0)     //A draw (BINGO)
                {
                    winning = _giveawayData.RoundDrawMonetaryValue;
                    bingoRound = true;
                }
                else if (Score >= 10)    //A big win
                {
                    winning = _giveawayData.RoundBigWinMonetaryValue;
                    wonRound = true;
                }
                else    //A small win
                {
                    winning = _giveawayData.RoundSmallWinMonetaryValue;
                    wonRound = true;
                }

                animateVarForWinnings = CurrentWinnings;

                //check if current round winning puts you equal/above max possible win
                if ((CurrentWinnings + winning) >= MaxPossibleWinnings)
                {
                    winning = MaxPossibleWinnings - CurrentWinnings;
                    CurrentWinnings = MaxPossibleWinnings;
                    isGameOver = isMaxWinAchieved();
                }
                else
                {
                    CurrentWinnings += winning;
                }
                ShowCashOutBtn = CurrentWinnings >= userGamePlayData.MinCashOut;
                //winMsg += ShowCashOutBtn ? "\nYou can cashout or Play for more" : "";
                ShowResetBtn = !ShowCashOutBtn;

                winMsg = $"You won N{winning.ToString("N0")}! ";
                ShowWinningMessage(wonRound, lostRound, bingoRound, winMsg);
                if (bingoRound)
                {
                    // Trigger the Congrats Badge animation
                    await JSRuntime.InvokeVoidAsync("showCongratsBadge");
                }
                // Call the JS function to trigger confetti
                await JSRuntime.InvokeVoidAsync("triggerConfetti");

                await AnimateNumberChange(value => animateVarForWinnings = value, animateVarForWinnings, CurrentWinnings);
            }
            else
            {
                playerWon = false;

                if (CurrentWinnings > 0)
                {
                    if (Score <= -10)    //A big loss
                    {
                        loss = _giveawayData.RoundBigLossMonetaryValue;
                        lostRound = true;
                    }
                    else    //A small loss
                    {
                        loss = _giveawayData.RoundSmallLossMonetaryValue;
                        lostRound = true;
                    }
                    ShowCashOutBtn = (CurrentWinnings - loss) >= userGamePlayData.MinCashOut;
                    //winMsg += ShowCashOutBtn ? "\nYou can cashout or Play for more" : "";
                    ShowResetBtn = !ShowCashOutBtn;

                    lossMsg = $"You lost N{loss.ToString("N0")}!";
                    ShowWinningMessage(wonRound, lostRound, bingoRound, lossMsg);
                    // Call the JavaScript function to trigger the loss effect
                    await JSRuntime.InvokeVoidAsync("triggerLossEffect");

                    animateVarForWinnings = CurrentWinnings;
                    CurrentWinnings -= loss;
                    await AnimateNumberChange(value => animateVarForWinnings = value, animateVarForWinnings, CurrentWinnings);
                }
            }

            // ShowCashOutBtn = CurrentWinnings >= userGamePlayData.MinCashOut;
            // winMsg += ShowCashOutBtn ? "\nYou can cashout or Play for more" : "";
            // ShowResetBtn = !ShowCashOutBtn;

            if (playerWon)
            {
                if (isMaxWinAchieved())
                {
                    winMsg = $"You can now cashout your winnings of N{CurrentWinnings.ToString("N0")}";
                }
                additionalMsg = winMsg;
            }
            else
            {
                // Player did not meet winning criteria
                additionalMsg = lossMsg;
            }

            //ShowToast(additionalMsg);
            //ShowWinningMessage(additionalMsg);
            // ShowDialog = true;
            // alertDialogParams.AlertTitle = roundCompleteMsg;
            // alertDialogParams.AlertMessage = new MarkupString(additionalMsg);
            // alertDialogParams.PrimaryBtnText = "Ok";
            // alertDialogParams.ShowSecondaryBtn = false;
            // alertDialogParams.OnPrimaryButtonClick = EventCallback.Factory.Create(this, AlertDialogPrimaryClicked);
            // alertDialogParams.OnSecondaryButtonClick = EventCallback.Factory.Create(this, AlertDialogSecondaryClicked);

            //save usergameplaydata to indexeddb
            SaveGamePlayProgressToIndexedDB();

            //save usergameplaydata to firebase
            try
            {
                bool userSaved = await CommonFunctions.SaveUserGamePlayDataToFirebase(userGamePlayData);
            }
            catch(Exception x)
            {
                Console.WriteLine($"Error saving gameplay data to firebase - {x.Message}");
            }
        }
    }

    private bool isMaxWinAchieved()
    {
        if (CurrentWinnings == MaxPossibleWinnings)
        {
            if (CoinImage != "images/coin_locked.png")
                LockGame();
            return true;
        }
        return false;
    }

    private async void LockGame()
    {
        ShowCashOutBtn = CurrentWinnings >= userGamePlayData.MinCashOut && !userGamePlayData.CashedOut;
        ShowResetBtn = false;
        //isFlipping = true; //this prevents clicks
        CoinImage = "images/coin_locked.png";
        StateHasChanged();

        //Write to firebase db signifying end of game
        if (userGamePlayData != null && !userGamePlayData.GameOver)
        {
            Console.WriteLine("Game over");
            userGamePlayData.GameOver = true;
            try
            {
                bool userSaved = await CommonFunctions.SaveUserGamePlayDataToFirebase(userGamePlayData);
            }
            catch (Exception x)
            {
                Console.WriteLine($"Error saving gameplay data to firebase - {x.Message}");
            }
        }
    }

    private async Task GetLeftoverGiveawayFundsFromFirebase()
    {
        try
        {
            // Start polling every 60 seconds (60000 milliseconds)
            _timer = new Timer(async _ =>
            {
                try
                {
                    // Capture the response from the Firebase service call
                    var response = await FirebaseService.PollFirebaseForLeftoverGiveawayFunds(_lastETag);

                    // Store the response in a variable
                    if (response != null)
                    {
                        httpResponseMessage = response;
                        StateHasChanged();
                        _lastETag = httpResponseMessage.Headers.ETag?.Tag ?? null;

                        LeftoverGiveawayFunds = int.Parse(await response.Content.ReadAsStringAsync());
                        await AnimateNumberChange(value => animateVarForLeftoverGiveawayFunds = value, animateVarForLeftoverGiveawayFunds, LeftoverGiveawayFunds);

                        await UpdateMonetaryValuesBasedOnLeftverFunds();
                    }
                }
                catch (Exception ex)
                {
                    await CommonFunctions.WriteErrorMessageToFirebase(ex.Message, "HeadsOrTails - GetLeftOverGiveawayFundsFromFirebase()", DateTime.Now.ToString());
                    Console.WriteLine($"Error during polling: {ex.Message}");
                }
            }, null, 0, 60000);
        }
        catch (Exception ex)
        {
            await CommonFunctions.WriteErrorMessageToFirebase(ex.Message, "HeadsOrTails - GetLeftOverGiveawayFundsFromFirebase()", DateTime.Now.ToString());
            Console.WriteLine($"Error fetching data: {ex.Message}");
        }
    }

    private async Task UpdateMonetaryValuesBasedOnLeftverFunds()
    {
        //adjust users current winnings and maximum win amounts to match leftoverfunds
        if (LeftoverGiveawayFunds <= CurrentWinnings || LeftoverGiveawayFunds <= MaxPossibleWinnings)
        {
            if (LeftoverGiveawayFunds <= CurrentWinnings)
            {
                animateVarForMaximumWin = MaxPossibleWinnings;
                animateVarForWinnings = CurrentWinnings;
                MaxPossibleWinnings = LeftoverGiveawayFunds;
                CurrentWinnings = LeftoverGiveawayFunds;

                await Task.WhenAll(
                     AnimateNumberChange(value => animateVarForWinnings = value, animateVarForWinnings, CurrentWinnings),
                 AnimateNumberChange(value => animateVarForMaximumWin = value, animateVarForMaximumWin, MaxPossibleWinnings));
            }
            else if (LeftoverGiveawayFunds <= MaxPossibleWinnings)
            {
                animateVarForMaximumWin = MaxPossibleWinnings;
                MaxPossibleWinnings = LeftoverGiveawayFunds;

                await AnimateNumberChange(value => animateVarForMaximumWin = value, animateVarForMaximumWin, MaxPossibleWinnings);
            }

            var userGamePlayData = new UserGamePlayData();

            //get most recent data from indexeddb
            try
            {
                using (var db = await this.DbFactory.Create<JusGiveawayDB>())
                {
                    userGamePlayData = CommonFunctions.GetUserGamePlayDataFromIndexedDb(db, PlayerUID);

                    if (userGamePlayData != null)
                    {
                        userGamePlayData.CurrentWinnings = (int)CurrentWinnings;
                        userGamePlayData.MaxPossibleWinnings = (int)MaxPossibleWinnings;

                        await db.SaveChanges();
                    }
                }
            }
            catch (Exception ex)
            {
                await CommonFunctions.WriteErrorMessageToFirebase(ex.Message, "HeadsOrTails - UpdateMonetaryValuesBasedOnLeftOverFunds()", DateTime.Now.ToString());
                Console.WriteLine(ex.Message);
            }

            //save usergameplaydata to firebase
            if (userGamePlayData != null)
            {
                try
                {
                    bool userSaved = await CommonFunctions.SaveUserGamePlayDataToFirebase(userGamePlayData);
                }
                catch (Exception x)
                {
                    Console.WriteLine($"Error saving gameplay data to firebase - {x.Message}");
                }
            }

            //check if we should lock game
            isMaxWinAchieved();
        }
    }

    private async Task ShakeImage()
    {
        isShaking = true; // Add the class to trigger animation
        StateHasChanged(); // Update the UI

        await Task.Delay(500); // Wait for the animation to complete

        isShaking = false; // Remove the class after animation
        StateHasChanged(); // Update the UI again
    }

    public void Dispose()
    {
        _timer?.Dispose();  // Dispose the timer when the component is destroyed
                            // Dispose the object reference to prevent memory leaks
        objRef?.Dispose();
        JSRuntime.InvokeVoidAsync("removeBackButtonListener");


        // Unsubscribe when the component is disposed
        NavigationManager.LocationChanged -= OnLocationChanged;
        Console.WriteLine("inside dispose function #####################");
        var _ =  CommonFunctions.WriteErrorMessageToFirebase("Inside Dispose()", "inside dispose()", DateTime.Now.ToString());
    }

    private async void AlertDialogPrimaryClicked()
    {
        ShowDialog = false;

        if (ShowResetBtn)
        {
            ShowResetBtn = false;
            await ResetDataInDBs();
            await ResetUI();
            ShowToast($"You can switch now");
        }

        if (ShowCashOutBtn)
        {
            LockGame();

            //maybe save gamedata to fb here, to make sure everything gets saved properly

            NavigationManager.NavigateTo($"/cashout/{PlayerUID}");
        }
    }

    private void AlertDialogSecondaryClicked()
    {
        ShowDialog = false;
    }

    private void ShowToast(string message)
    {
        toastMessage = message;
        isToastVisible = true;

        // Auto-hide the toast after 5 seconds
        _ = Task.Delay(5000).ContinueWith(t =>
        {
            InvokeAsync(() =>
            {
                isToastVisible = false;
                StateHasChanged();
            });
        });
    }

    private async void OnLocationChanged(object sender, LocationChangedEventArgs e)
    {
        // Check if saving is in progress to prevent multiple saves
        if (!isSaving)
        {
            isSaving = true;
            Console.WriteLine("Saving progress due to navigation away from page");
            //currently buggy
            //await CommonFunctions.SaveUserProgressOnExit(this.DbFactory, PlayerUID, HeadsCount, TailsCount); 
            isSaving = false;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender && isUserLoggedIn)
        {
            // Creating a DotNetObjectReference to pass to JavaScript
            objRef = DotNetObjectReference.Create(this);

            await JSRuntime.InvokeVoidAsync("onPageExit", objRef);
            // Load the JavaScript to track inactivity
            await JSRuntime.InvokeVoidAsync("inactivityTimer", objRef);

            await JSRuntime.InvokeVoidAsync("addBackButtonListener", objRef);
        }
    }

    [JSInvokable]
    public void SaveProgressOnExit()
    {
        // Logic to save progress goes here
        // e.g., Save to IndexedDB or trigger an API to save progress
        Console.WriteLine("Saving progress on page exit...");
    }

    [JSInvokable]
    public async void HandleBackButtonPress()
    {
        Console.WriteLine("Browser Back button pressed" + " -> H-" + HeadsCount + "T-" + TailsCount);
        await CommonFunctions.SaveUserProgressOnExit(this.DbFactory, PlayerUID, HeadsCount, TailsCount);
    }

    private async void OnBackBtnClicked()
    {
        Console.WriteLine("Game Back button pressed" + " -> H-" + HeadsCount + "T-" + TailsCount);
        await CommonFunctions.SaveUserProgressOnExit(this.DbFactory, PlayerUID, HeadsCount, TailsCount);
        NavigationManager.NavigateTo($"/mainpage/{PlayerUID}");
    }

    private static async Task YourLogoutFunction()
    {
        // Logic to log out the user (e.g., clear session, token)
        //Console.WriteLine("inside logoutfunction");
        //CommonFunctions.SaveUserProgressOnExit(this.DbFactory, PlayerUID, HeadsCount, TailsCount);
    }

    [JSInvokable]
    public async Task LogoutUser()
    {
        //function to log out user due to inactivity
        isUserLoggedIn = false;  // Set the flag to false on logout

        // Clear any user session data or tokens
        await CommonFunctions.SignOutUser(this.DbFactory, PlayerUID);

        Console.WriteLine("inside logoutuser - " + isUserLoggedIn);
        await CommonFunctions.SaveUserProgressOnExit(this.DbFactory, PlayerUID, HeadsCount, TailsCount);
        // Optionally redirect to the login page
        NavigationManager.NavigateTo("/");

        // Clear the inactivity timer after logout
        await JSRuntime.InvokeVoidAsync("clearInactivityTimer");
    }

    private async Task OnLoginSuccess()
    {
        // Your existing login logic here...

        // Reset the inactivity timer's logged out flag
        await JSRuntime.InvokeVoidAsync("resetUserLoggedOutFlag");

        // Set up the inactivity timer again after login
        await JSRuntime.InvokeVoidAsync("inactivityTimer", objRef);
    }

    private bool wonRound;
    private bool lostRound;
    private bool bingoRound;

    private void ShowWinningMessage(bool win, bool loss, bool bingo, string msg)
    {
        EndOfRoundMessage = msg;
        wonRound = win; // Show the winning message
        lostRound = loss; // Show the losing message
        bingoRound = bingo; // Show the bingo message
        StateHasChanged(); // Trigger a UI update

        // Start the animation
        Task.Delay(2000).ContinueWith(_ =>
        {
            InvokeAsync(() =>
            {
                wonRound = false; // Hide the winning message
                lostRound = false; // Hide the losing message
                bingoRound = false; // Hide the bingo message
                StateHasChanged(); // Trigger a UI update
            });
        });
    }

    private void OnSponsoredByTapped()
    {
        ShowModal = true;
    }

    private Task OnModalStateChanged(bool isVisible)
    {
        ShowModal = isVisible;
        return Task.CompletedTask;
    }
}